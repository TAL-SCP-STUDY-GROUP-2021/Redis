# redis持久化

redis提供了两种持久化的方式：

* RDB:快照持久化 
* AOF:对写操作命令的日志

RDB快照记录某一时间结点的内存数据，记录实际数据，AOF文件记录修改类型的操作命令的日志。

在进行数据恢复时，RDB的效率要高于AOF，但在持久化的过程中AOF的效率更高，对资源的占用也更少。

## RDB快照

快照是对于某一瞬间事务状态的记录，Redis的数据都存储在内存中，RDB快照就是对某一时间点内存数据的记录。

Redis提供了两个命令来生成快照：

* `save`  在主线程生成RDB文件，会阻塞执行操作命令
* `bgsave` 创建一个子进程生成RDB文件，避免主线程的阻塞

默认情况下，通过后台生成的方式创建RDB文件，RDB的加载是在redis服务启动时自动执行的。

redis的配置文件中提供如下配置：

~~~
save 900 1
save 300 10
save 60 10000
~~~

上述配置执行的是`bgsave`命令，只要满足任意条件，就会触发bgsave，其含义分别为：

* 900秒内，至少进行一次数据的修改
* 300秒内，至少进行10次数据的修改
* 60秒内，至少进行10000次数据的修改

由于redis的RDB快照进行的是全量快照，是一个比较重的操作，如果太过频繁，会对redis性能产生影响，如果频率太低，在发生故障的时候丢失的数据会更多。

### bgsave的过程

在执行bgsave时，首先对主进程进行fork()创建一个进程(save进程)，save进程会复制一份主进程的页表，但页表实际指向的物理内存和主进程一致，如图所示：

<img src="redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211011162558788.png" alt="image-20211011162558788" style="zoom:50%;" />

进行bgsave的目的就是不阻塞主进程执行操作命令，那么是如何解决数据在save过程中被修改的问题？

<img src="redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211011163033888.png" alt="image-20211011163033888" style="zoom:50%;" />

如果再执行bgsave的过程中，数据被修改，将数据对应物理内存复制一份，子进程的执行新的物理地址，主进程在原有物理地址上对数据进行修改。

可以发现，bgsave只对bgsave开始时间点之前的数据进行持久化操作，在该时间点之后修改的数据会存储在内存中，但是不会写入当前的RDB文件中。



## AOF

### 基础

AOF用于记录redis的命令，做增量备份。

<img src="redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211012142046963.png" alt="image-20211012142046963" style="zoom:50%;" />

Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处：

* 避免额外的检查开销

  如果先记录命令至AOF中，再执行命令，如果在命令执行过程中，产生意外，会导致aof数据和实际数据不一致。诸如mysql的两段式提交，可以保证数据和逻辑的一致性，但是会产生格外的检查开销。

* 不会阻塞当前写操作命令的执行

但同时也存在风险：

* 如果写内存之后写日志之前宕机，会丢失数据
* 给下一条命令的写带来阻塞风险

和mysql中一致的是，都会将操作命令先记录到缓冲区中，然后根据不同的策略选择不同的时机进行落盘的操作，redis提供了三种策略：

* always： 每次写操作命令后，同步将AOF日志数据写入磁盘
* everysec：每次写操作之后，将命令追加到AOF缓冲区，然后每隔1s进行一次落盘操作
* no：每次写操作之后，将命令追加到AOF缓冲区，由操作系统决定何时将缓冲区内容写入磁盘

<img src="redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211012144806678.png" alt="image-20211012144806678" style="zoom:50%;" />

### AOF重写

随着写操作的命令越来越多，AOF文件也会越来越大。AOF文件大就会带来性能问题，比如恢复数据的过程中，如果AOF文件中包含了很多无效的命令，就会浪费额外的时间，降低了效率，是的恢复的过程变得漫长。因此，为避免AOF文件过大，redis提供了AOF文件重写机制，当AOF文件的大小超过阈值时，会启动AOF重写机制，生成一份新的AOF文件替代原有AOF文件。

过程：

当AOF文件的大小超过阈值时，触发AOF重写，首先由主进程fork()生成子进程，子进程复制了父进程页表，该页表记录虚拟地址和物理地址映射关系，父子进程共享一份只读的物理内存。子进程会新建一份AOF文件，然后在根据内存中的数据生成对应的命令将其写入新的AOF文件中。如果此时数据被修改，则发生写时复制，复制一块新的物理内存给子进程，由主进程在原有位置对数据进行修改，同时在主进程中会开辟一块重写缓冲区，在将修改的命令写入aof缓冲区的同时，将命令也追加到aof重写缓冲区中。当子进程将所有内存中的数据都转换为操作命令并记录到AOF文件后，发送信号给主进程。之后主进程会将AOF重写缓冲区的内容追加到新的AOF文件中，并对该文件重命名，覆盖现有的AOF文件。

### AOF配置

默认情况下，redis不开启AOF，可以通过配置redis.conf文件来开启AOF，配置如下：

~~~
# appendonly参数开启AOF持久化
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
~~~

